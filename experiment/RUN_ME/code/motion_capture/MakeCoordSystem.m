function [T_glob_loc,T_loc_glob]=MakeCoordSystem(p1_xyz,p2_xyz,p3_xyz)% Function to create coordinate transform given 3 points.  Assumes that% first point defines local origin, second point is along the x-axis and% point 3 is on the x-y plane.% This routine uses the function inv4x4.m% Inputs:%  p1_xyz --> 1 x 3 vector of x, y and z coordinate of 1st point%  p2_xyz --> 1 x 3 vector of x, y and z coordinate of 2nd point%  p3_xyz --> 1 x 3 vector of x, y and z coordinate of 3rd point% Outputs:%  T_glob_loc --> 4 x 4 transformation matrix to go from global (tracker)%  coordinates to local coordinate%  T_loc_glob --> 4 x 4 transformation matrix to go from local to global%  coordinates (inverse of T_glob_loc)% Note:  The 4 x 4 transformation matrix consists of the 3 x 3 rotation% matrix in the upper left hand corner and the translation vector as the% first 3 rows of the 4th column.  The last row is [0 0 0 1].% To transform a point (or many points), you can use transform4.m% USES:%  inv4x4.m% Created:  June 12/07 (J. Lanovaz)% Modified: June 12/07% =================================% Error check:if nargin~=3    disp('*** ERROR in MakeCoordSystem.m          ***')    disp('*** Incorrect number of input arguments ***')    T_glob_loc = eye(4);    T_loc_glob = eye(4);    returnend% Forcing row vectors (just to be safe):p1_xyz = p1_xyz(:)';p2_xyz = p2_xyz(:)';p3_xyz = p3_xyz(:)';% Making axis vectors:xv = p2_xyz - p1_xyz;v1 = p3_xyz - p1_xyz;xvn = xv/norm(xv);v1n = v1/norm(v1);zv = cross(xvn,v1n);zvn = zv/norm(zv);yv = cross(zvn,xvn);yvn = yv/norm(yv);% Making transformation matricies:R = [xvn' yvn' zvn'];T_loc_glob = eye(4);T_loc_glob(1:3,1:3) = R;T_loc_glob(1:3,4) = p1_xyz';T_glob_loc = inv4x4(T_loc_glob);return